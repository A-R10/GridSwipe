<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Grid Path Puzzle</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: #111827;
            color: white;
            font-family: system-ui, -apple-system, sans-serif;
            touch-action: none;
            -webkit-user-select: none;
            user-select: none;
            overflow: hidden;
            position: fixed;
            width: 100%;
            height: 100vh;
        }
        
        #root {
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }
        
        .game-container {
            background: #1f2937;
            border-radius: 12px;
            padding: 24px;
            max-width: 400px;
            width: 100%;
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
        }
        
        .title {
            font-size: 32px;
            font-weight: bold;
            color: #fb923c;
            text-align: center;
            margin-bottom: 8px;
        }
        
        .subtitle {
            color: #d1d5db;
            text-align: center;
            margin-bottom: 4px;
        }
        
        .description {
            color: #9ca3af;
            font-size: 14px;
            text-align: center;
            margin-bottom: 16px;
        }
        
        .difficulty-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin: 16px 0 24px 0;
        }
        
        .difficulty-btn {
            padding: 16px;
            border: none;
            border-radius: 8px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
            background: #374151;
            color: #d1d5db;
        }
        
        .difficulty-btn.active {
            background: #ea580c;
            color: white;
        }
        
        .difficulty-btn:hover {
            background: #4b5563;
        }
        
        .difficulty-btn.active:hover {
            background: #dc2626;
        }
        
        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.2s;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            width: 100%;
        }
        
        .btn-primary {
            background: #059669;
            color: white;
            font-size: 18px;
            padding: 16px;
        }
        
        .btn-primary:hover {
            background: #047857;
        }
        
        .btn-small {
            padding: 8px;
            width: 40px;
            height: 40px;
            min-width: 40px;
        }
        
        .btn-yellow { background: #d97706; color: white; }
        .btn-yellow:hover { background: #b45309; }
        .btn-blue { background: #2563eb; color: white; }
        .btn-blue:hover { background: #1d4ed8; }
        .btn-purple { background: #7c3aed; color: white; }
        .btn-purple:hover { background: #6d28d9; }
        .btn-orange { background: #ea580c; color: white; }
        .btn-orange:hover { background: #dc2626; }
        .btn-gray { background: #374151; color: white; }
        .btn-gray:hover { background: #4b5563; }
        
        .btn:disabled {
            background: #374151;
            color: #6b7280;
            cursor: not-allowed;
        }
        
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
        }
        
        .header-center {
            text-align: center;
        }
        
        .next-number {
            font-size: 18px;
            font-weight: bold;
            color: #fb923c;
        }
        
        .difficulty-label {
            font-size: 12px;
            color: #9ca3af;
        }
        
        .stats {
            display: flex;
            justify-content: space-between;
            font-size: 14px;
            color: #d1d5db;
            margin-bottom: 16px;
        }
        
        .game-board {
            display: flex;
            justify-content: center;
            margin-bottom: 24px;
        }
        
        .grid-container {
            position: relative;
            background: #f3f4f6;
            border-radius: 8px;
            padding: 8px;
            width: 300px;
            height: 300px;
        }
        
        .game-grid {
            position: absolute;
            top: 8px;
            left: 8px;
            width: 284px;
            height: 284px;
            display: grid;
            gap: 2px;
        }
        
        .grid-cell {
            background: white;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }
        
        .grid-cell:hover {
            background: #e5e7eb;
        }
        
        .grid-cell.visited {
            background: #fed7aa;
        }
        
        .grid-cell.hint {
            background: #fde047;
            animation: pulse 2s infinite;
        }
        
        .number-circle {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #374151;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            font-weight: bold;
        }
        
        .number-circle.visited {
            background: #ea580c;
        }
        
        .path-canvas {
            position: absolute;
            top: 8px;
            left: 8px;
            pointer-events: none;
            width: 284px;
            height: 284px;
        }
        
        .completion {
            background: #166534;
            border: 2px solid #22c55e;
            border-radius: 8px;
            padding: 24px;
            text-align: center;
            margin-bottom: 24px;
        }
        
        .trophy {
            font-size: 48px;
            margin-bottom: 16px;
        }
        
        .completion-title {
            font-size: 20px;
            font-weight: bold;
            color: #86efac;
            margin-bottom: 8px;
        }
        
        .completion-stats {
            color: #bbf7d0;
            font-size: 14px;
            margin-bottom: 16px;
        }
        
        .completion-buttons {
            display: flex;
            gap: 8px;
            justify-content: center;
        }
        
        .footer {
            text-align: center;
            font-size: 12px;
            color: #6b7280;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
    </style>
</head>
<body>
    <div id="root">
        <div class="game-container" id="game">
            <!-- Game content will be inserted here -->
        </div>
    </div>

    <script>
        let gameState = {
            difficulty: 'easy',
            state: 'menu',
            grid: [],
            path: [],
            currentNumber: 1,
            score: 0,
            startTime: null,
            timeElapsed: 0,
            showHint: false,
            backtracks: 0,
            isDragging: false,
            dragPath: []
        };

        const difficulties = {
            easy: { size: 4 },
            medium: { size: 5 },
            hard: { size: 6 },
            expert: { size: 7 }
        };

        let canvas, ctx, gridElement, timerInterval;

        // Prevent scrolling
        document.addEventListener('touchmove', (e) => e.preventDefault(), { passive: false });
        document.addEventListener('touchstart', (e) => e.preventDefault(), { passive: false });

        function generateGrid(size) {
            const grid = [];
            for (let i = 0; i < size; i++) {
                const row = [];
                for (let j = 0; j < size; j++) {
                    row.push({ value: 0, row: i, col: j, visited: false });
                }
                grid.push(row);
            }
            
            const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]];
            const usedCells = new Set();
            
            let currentRow = Math.floor(Math.random() * size);
            let currentCol = Math.floor(Math.random() * size);
            
            usedCells.add(`${currentRow},${currentCol}`);
            grid[currentRow][currentCol].value = 1;
            
            for (let num = 2; num <= size * size; num++) {
                const validMoves = [];
                
                for (const [dr, dc] of directions) {
                    const newRow = currentRow + dr;
                    const newCol = currentCol + dc;
                    
                    if (newRow >= 0 && newRow < size && 
                        newCol >= 0 && newCol < size && 
                        !usedCells.has(`${newRow},${newCol}`)) {
                        validMoves.push([newRow, newCol]);
                    }
                }
                
                if (validMoves.length === 0) {
                    return generateGrid(size);
                }
                
                const [nextRow, nextCol] = validMoves[Math.floor(Math.random() * validMoves.length)];
                
                usedCells.add(`${nextRow},${nextCol}`);
                grid[nextRow][nextCol].value = num;
                
                currentRow = nextRow;
                currentCol = nextCol;
            }
            
            return grid;
        }

        function startGame() {
            const config = difficulties[gameState.difficulty];
            gameState.grid = generateGrid(config.size);
            gameState.path = [];
            gameState.currentNumber = 1;
            gameState.state = 'playing';
            gameState.score = 0;
            gameState.startTime = Date.now();
            gameState.timeElapsed = 0;
            gameState.showHint = false;
            gameState.backtracks = 0;
            gameState.isDragging = false;
            gameState.dragPath = [];
            
            startTimer();
            render();
        }

        function startTimer() {
            if (timerInterval) clearInterval(timerInterval);
            timerInterval = setInterval(() => {
                if (gameState.state === 'playing' && gameState.startTime) {
                    gameState.timeElapsed = Date.now() - gameState.startTime;
                    updateTimer();
                }
            }, 100);
        }

        function updateTimer() {
            const timeElement = document.getElementById('timer');
            if (timeElement) {
                timeElement.textContent = `Time: ${(gameState.timeElapsed / 1000).toFixed(1)}s`;
            }
        }

        function getCellFromCoords(clientX, clientY) {
            if (!gridElement || !gameState.grid.length) return null;
            
            const gridRect = gridElement.getBoundingClientRect();
            const config = difficulties[gameState.difficulty];
            const cellSize = 284 / config.size;
            
            const x = clientX - gridRect.left;
            const y = clientY - gridRect.top;
            
            if (x < 0 || y < 0) return null;
            
            const col = Math.floor(x / cellSize);
            const row = Math.floor(y / cellSize);
            
            if (row >= 0 && row < config.size && col >= 0 && col < config.size) {
                return { row, col };
            }
            
            return null;
        }

        function drawPath() {
            if (!canvas || !ctx) return;
            
            const config = difficulties[gameState.difficulty];
            const cellSize = 284 / config.size;
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            const currentPath = gameState.isDragging ? gameState.dragPath : gameState.path;
            
            if (currentPath.length < 2) return;
            
            ctx.strokeStyle = '#ff6b35';
            ctx.lineWidth = 6;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            
            ctx.beginPath();
            const start = currentPath[0];
            const startX = (start.col + 0.5) * cellSize;
            const startY = (start.row + 0.5) * cellSize;
            ctx.moveTo(startX, startY);
            
            for (let i = 1; i < currentPath.length; i++) {
                const current = currentPath[i];
                const x = (current.col + 0.5) * cellSize;
                const y = (current.row + 0.5) * cellSize;
                ctx.lineTo(x, y);
            }
            ctx.stroke();
            
            for (let i = 0; i < currentPath.length; i++) {
                const cell = currentPath[i];
                const x = (cell.col + 0.5) * cellSize;
                const y = (cell.row + 0.5) * cellSize;
                
                ctx.fillStyle = 'rgba(255, 107, 53, 0.3)';
                ctx.beginPath();
                ctx.arc(x, y, 8, 0, 2 * Math.PI);
                ctx.fill();
                
                ctx.fillStyle = '#ff6b35';
                ctx.beginPath();
                ctx.arc(x, y, 5, 0, 2 * Math.PI);
                ctx.fill();
            }
        }

        function handleDragStart(e) {
            if (gameState.state !== 'playing') return;
            
            e.preventDefault();
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            
            const cellCoords = getCellFromCoords(clientX, clientY);
            if (!cellCoords) return;
            
            const { row, col } = cellCoords;
            const cell = gameState.grid[row][col];
            
            if (cell.value === gameState.currentNumber) {
                gameState.isDragging = true;
                gameState.dragPath = [{ row, col, value: cell.value }];
                drawPath();
            } else {
                gameState.backtracks++;
                updateScore();
            }
        }

        function handleDragMove(e) {
            if (gameState.state !== 'playing') return;
            
            e.preventDefault();
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            
            const cellCoords = getCellFromCoords(clientX, clientY);
            if (!cellCoords) return;
            
            const { row, col } = cellCoords;
            const cell = gameState.grid[row][col];
            
            if (!gameState.isDragging) {
                if (cell.value === gameState.currentNumber) {
                    gameState.isDragging = true;
                    gameState.dragPath = [{ row, col, value: cell.value }];
                }
                return;
            }
            
            if (gameState.dragPath.length === 0) return;
            
            const lastCell = gameState.dragPath[gameState.dragPath.length - 1];
            const expectedNumber = gameState.dragPath.length + gameState.currentNumber - 1;
            
            if (row === lastCell.row && col === lastCell.col) return;
            
            const existingIndex = gameState.dragPath.findIndex(p => p.row === row && p.col === col);
            if (existingIndex >= 0) {
                gameState.dragPath = gameState.dragPath.slice(0, existingIndex + 1);
                drawPath();
                return;
            }
            
            const rowDiff = Math.abs(row - lastCell.row);
            const colDiff = Math.abs(col - lastCell.col);
            
            if ((rowDiff === 1 && colDiff === 0) || (rowDiff === 0 && colDiff === 1)) {
                if (cell.value === expectedNumber + 1 && !cell.visited) {
                    gameState.dragPath.push({ row, col, value: cell.value });
                    drawPath();
                }
            }
        }

        function handleDragEnd(e) {
            if (!gameState.isDragging) return;
            
            e.preventDefault();
            
            setTimeout(() => {
                if (gameState.dragPath.length > 0) {
                    for (const dragCell of gameState.dragPath) {
                        if (dragCell.value === gameState.currentNumber) {
                            gameState.grid[dragCell.row][dragCell.col].visited = true;
                            gameState.path.push(dragCell);
                            gameState.currentNumber++;
                        }
                    }
                    
                    updateScore();
                    
                    const config = difficulties[gameState.difficulty];
                    const totalCells = config.size * config.size;
                    
                    if (gameState.currentNumber - 1 === totalCells) {
                        gameState.state = 'completed';
                        if (timerInterval) clearInterval(timerInterval);
                    }
                    
                    render();
                }
                
                gameState.isDragging = false;
                gameState.dragPath = [];
                drawPath();
            }, 100);
        }

        function updateScore() {
            gameState.score = Math.max(0, 
                gameState.path.length * difficulties[gameState.difficulty].size * 10 - 
                gameState.backtracks * 5
            );
            const scoreElement = document.getElementById('score');
            if (scoreElement) {
                scoreElement.textContent = `Score: ${gameState.score}`;
            }
            const backtrackElement = document.getElementById('backtracks');
            if (backtrackElement) {
                backtrackElement.textContent = `Backtracks: ${gameState.backtracks}`;
            }
        }

        function undoMove() {
            if (gameState.path.length === 0 || gameState.state !== 'playing') return;
            
            const lastMove = gameState.path.pop();
            gameState.grid[lastMove.row][lastMove.col].visited = false;
            gameState.currentNumber--;
            gameState.backtracks++;
            
            updateScore();
            render();
        }

        function resetGame() {
            gameState.state = 'menu';
            if (timerInterval) clearInterval(timerInterval);
            render();
        }

        function toggleHint() {
            gameState.showHint = !gameState.showHint;
            render();
        }

        function takeScreenshot() {
            alert(`Screenshot saved!\nScore: ${gameState.score}\nTime: ${(gameState.timeElapsed/1000).toFixed(1)}s`);
        }

        function setDifficulty(difficulty) {
            gameState.difficulty = difficulty;
            render();
        }

        function render() {
            const gameElement = document.getElementById('game');
            
            if (gameState.state === 'menu') {
                gameElement.innerHTML = `
                    <div class="title">Grid Path Puzzle</div>
                    <div class="subtitle">Connect numbers 1→2→3... in sequence</div>
                    <div class="description">Drag/swipe through numbers - only 90° moves</div>
                    
                    <div style="color: #fb923c; text-align: center; margin-bottom: 16px; font-size: 14px;">
                        🎯 Flowing path shows your route
                    </div>
                    
                    <div style="color: #d1d5db; font-size: 14px; margin-bottom: 8px;">Choose Difficulty:</div>
                    <div class="difficulty-grid">
                        ${Object.entries(difficulties).map(([level, config]) => `
                            <button class="difficulty-btn ${gameState.difficulty === level ? 'active' : ''}" 
                                    onclick="setDifficulty('${level}')">
                                <div style="font-weight: bold; text-transform: capitalize;">${level}</div>
                                <div style="font-size: 12px;">${config.size}×${config.size} grid</div>
                                <div style="font-size: 12px;">${config.size * config.size} numbers</div>
                            </button>
                        `).join('')}
                    </div>
                    
                    <button class="btn btn-primary" onclick="startGame()">
                        ▶ Start Game
                    </button>
                `;
            } else {
                const config = difficulties[gameState.difficulty];
                const gridSize = config.size;
                const cellSize = 284 / gridSize;
                
                gameElement.innerHTML = `
                    <div class="header">
                        <div style="display: flex; gap: 8px;">
                            <button class="btn btn-small btn-yellow" onclick="undoMove()" ${gameState.path.length === 0 ? 'disabled' : ''}>↶</button>
                            <button class="btn btn-small ${gameState.showHint ? 'btn-blue' : 'btn-gray'}" onclick="toggleHint()">💡</button>
                        </div>
                        
                        <div class="header-center">
                            <div class="next-number">Next: ${gameState.currentNumber}</div>
                            <div class="difficulty-label">${gameState.difficulty.toUpperCase()}</div>
                        </div>
                        
                        <div style="display: flex; gap: 8px;">
                            <button class="btn btn-small btn-purple" onclick="takeScreenshot()">📸</button>
                            <button class="btn btn-small btn-gray" onclick="resetGame()">↻</button>
                        </div>
                    </div>
                    
                    <div class="stats">
                        <span id="score">Score: ${gameState.score}</span>
                        <span id="backtracks">Backtracks: ${gameState.backtracks}</span>
                        <span id="timer">Time: ${(gameState.timeElapsed/1000).toFixed(1)}s</span>
                    </div>

                    <div class="game-board">
                        <div class="grid-container">
                            <div class="game-grid" id="grid-element" style="grid-template-columns: repeat(${gridSize}, 1fr); grid-template-rows: repeat(${gridSize}, 1fr);">
                                ${gameState.grid.map((row, rowIndex) =>
                                    row.map((cell, colIndex) => `
                                        <div class="grid-cell ${
                                            cell.visited ? 'visited' : 
                                            cell.value === gameState.currentNumber && gameState.showHint ? 'hint' : ''
                                        }">
                                            <div class="number-circle ${cell.visited ? 'visited' : ''}">${cell.value}</div>
                                        </div>
                                    `).join('')
                                ).join('')}
                            </div>
                            <canvas class="path-canvas" id="path-canvas" width="284" height="284"></canvas>
                        </div>
                    </div>

                    ${gameState.state === 'completed' ? `
                        <div class="completion">
                            <div class="trophy">🏆</div>
                            <div class="completion-title">Puzzle Completed!</div>
                            <div class="completion-stats">
                                Final Score: ${gameState.score}<br>
                                Time: ${(gameState.timeElapsed/1000).toFixed(1)}s<br>
                                Backtracks: ${gameState.backtracks}
                            </div>
                            <div class="completion-buttons">
                                <button class="btn btn-purple" onclick="takeScreenshot()" style="width: auto;">📸 Save</button>
                                <button class="btn btn-orange" onclick="startGame()" style="width: auto;">Play Again</button>
                            </div>
                        </div>
                    ` : ''}

                    <div class="footer">
                        Drag/swipe 1→2→3... • Only 90° moves • Avoid backtracks for high score
                    </div>
                `;

                canvas = document.getElementById('path-canvas');
                ctx = canvas ? canvas.getContext('2d') : null;
                gridElement = document.getElementById('grid-element');
                
                if (gridElement) {
                    gridElement.addEventListener('mousedown', handleDragStart);
                    gridElement.addEventListener('mousemove', handleDragMove);
                    gridElement.addEventListener('mouseup', handleDragEnd);
                    gridElement.addEventListener('touchstart', handleDragStart);
                    gridElement.addEventListener('touchmove', handleDragMove);
                    gridElement.addEventListener('touchend', handleDragEnd);
                }
                
                drawPath();
            }
        }

        // Make functions global
        window.startGame = startGame;
        window.undoMove = undoMove;
        window.resetGame = resetGame;
        window.toggleHint = toggleHint;
        window.takeScreenshot = takeScreenshot;
        window.setDifficulty = setDifficulty;

        // Initialize
        render();
    </script>
</body>
</html>
